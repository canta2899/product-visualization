<!DOCTYPE html>
<html lang="en">
<head>
    <title>Showcase</title>

    <!-- Meta and links -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-F3w7mX95PdgyTmZZMECAngseQB83DfGTowi0iMjiWaeVhAn4FJkqJByhZMI3AhiU" crossorigin="anonymous">
    <link rel="stylesheet" href="style.css">

    <style>
        body {
            overflow: hidden;
        }
    </style>

    <!-- Bootstrap -->
    <script src="libs/jquery.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.1/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-/bQdsTh/da6pkI1MST/rWKFNjaCP5gBSY4sEBT38Q/9RBh9AH40zEOg7Hlq2THRZ"
            crossorigin="anonymous"></script>

    <!--ThreeJS-->
    <script src="libs/three.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/OBJLoader.js"></script>


    <!--Vertex shader-->
    <script type="text/x-glsl" id="vertex">
		attribute vec4 tangent;
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec3 wPosition;
		varying vec3 vTangent;
		varying vec3 vBitangent;
		varying vec2 vUv;
		
		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalize(normalMatrix * normal);
			vec3 objectTangent = vec3( tangent.xyz );
			vec3 transformedTangent = normalMatrix * objectTangent;
			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
			vUv = uv;
			gl_Position = projectionMatrix * vPos;
		}
    </script>

    <script type="text/x-glsl" id="fragment_metal">
        #define MEDIUMP_FLT_MAX    65504.0
        #define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
        varying vec3 vNormal;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec3 vPosition;
        varying vec3 wPosition;
        varying vec2 vUv;
        uniform vec3 pointLightPosition[8];
        uniform vec3 clight;
        uniform sampler2D metalnessMap;
        uniform sampler2D diffuseMap;
        uniform sampler2D roughnessMap;
        uniform sampler2D normalMap;
        uniform vec3 ambientLight;
        uniform samplerCube envMap;
        uniform vec2 normalScale;
        uniform vec2 textureRepeat;
        const float PI = 3.14159;

        vec3 cdiff;
        vec3 cspec;
        vec3 metalness;
        float roughness;

        float D_GGX(float NoH, float a) {
            float a2 = a * a;
            float f = (NoH * a2 - NoH) * NoH + 1.0;
            return a2 / (PI * f * f);
        }

        vec3 F_Schlick(float u, vec3 f0) {
            return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
        }

        float V_Kelemen(float LoH) {
            return 0.25 / (LoH * LoH);
        }

        float V_SmithGGXCorrelated(float NoV, float NoL, float a) {
            float a2 = a * a;
            float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
            float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
            return 0.5 / (GGXV + GGXL);
        }

        float Fd_Lambert() {
            return 1.0 / PI;
        }

        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

        void main() {
            vec3 v = normalize(-vPosition);
            vec3 normal = normalize( vNormal );
            vec3 tangent = normalize( vTangent );
            vec3 bitangent = normalize( vBitangent );
            mat3 vTBN = mat3( tangent, bitangent, normal );
            vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
            mapN.xy = normalScale * mapN.xy;
            vec3 n = normalize( vTBN * mapN );
            roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
            float nDotv = max(dot(n, v), 0.000001);
            vec3 worldN = inverseTransformDirection( n, viewMatrix );
            vec3 worldV = cameraPosition - wPosition ;
            vec3 r = normalize( reflect(-worldV,worldN));

            metalness = texture2D(metalnessMap, vUv*textureRepeat).rgb;
            metalness = pow(metalness, vec3(2.2));

            cdiff = texture2D(diffuseMap, vUv*textureRepeat).rgb;
            cdiff = pow(cdiff, vec3(2.2));
            vec3 baseColor = cdiff;
            cdiff = (vec3(1.0) - metalness) * cdiff;

            vec3 f0 = 0.16 * (vec3(1.0) - metalness) + baseColor * metalness;

            vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
			envLight = pow( envLight, vec3(2.2));

            vec3 totalColor;
            for (int i = 0; i < 6; i++) {
                vec4 lPosition = viewMatrix * vec4(pointLightPosition[i], 1.0);
                vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 h = normalize(v + l);
                float nDotl = max(dot(n, l), 0.000001);
                float lDoth = max(dot(l, h), 0.000001);
                float nDoth = max(dot(n, h), 0.000001);

                // specular BRDF
                float a = nDoth * roughness;
                float D = D_GGX(nDoth, a);
                float V = V_SmithGGXCorrelated(nDotv, nDotl, roughness);
                vec3  F = F_Schlick(lDoth, f0);
                vec3 Fr = (D * V) * F;

                // diffuse BRDF
                vec3 Fd = cdiff * Fd_Lambert();

                float clearCoatPerceptualRoughness = 1.0;
                clearCoatPerceptualRoughness = clamp(clearCoatPerceptualRoughness, 0.089, 1.0);
                float clearCoatRoughness = clearCoatPerceptualRoughness * clearCoatPerceptualRoughness;

                // clear coat BRDF
                float  Dc = D_GGX(nDoth, clearCoatRoughness);
                float  Vc = V_Kelemen(lDoth);
                vec3  Fc = F_Schlick(lDoth, vec3(0.04)) * 0.1; // clear coat strength
                vec3  Frc = (Dc * Vc) * Fc;

                vec3 color = cdiff * (Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc;
                color *= clight * nDotl;
                color = mix(color, envLight * F, 0.25);
                totalColor += color;
            }

            gl_FragColor = vec4(pow(totalColor, vec3(1.0/2.2)), 1.0);
        }
    </script>

    <script type="text/x-glsl" id="fragment_leather">
        #define MEDIUMP_FLT_MAX    65504.0
        #define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
        varying vec3 vNormal;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec3 vPosition;
        varying vec3 wPosition;
        varying vec2 vUv;
        uniform vec3 pointLightPosition[8];
        uniform vec3 clight;
        uniform sampler2D diffuseMap;
        uniform sampler2D roughnessMap;
        uniform sampler2D normalMap;
        uniform sampler2D specularMap;
        uniform vec2 normalScale;
        uniform vec2 textureRepeat;
        const float PI = 3.14159;

        vec3 cdiff;
        vec3 cspec;
        float roughness;

        float D_GGX(float NoH, float a) {
            float a2 = a * a;
            float f = (NoH * a2 - NoH) * NoH + 1.0;
            return a2 / (PI * f * f);
        }

        vec3 F_Schlick(float u, vec3 f0) {
            return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
        }

        float V_SmithGGXCorrelated(float NoV, float NoL, float a) {
            float a2 = a * a;
            float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
            float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
            return 0.5 / (GGXV + GGXL);
        }

        float Fd_Lambert() {
            return 1.0 / PI;
        }

        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

        void main() {
            vec3 v = normalize(-vPosition);
            vec3 normal = normalize( vNormal );
            vec3 tangent = normalize( vTangent );
            vec3 bitangent = normalize( vBitangent );
            mat3 vTBN = mat3( tangent, bitangent, normal );
            vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
            mapN.xy = normalScale * mapN.xy;
            vec3 n = normalize( vTBN * mapN );
            roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
            float nDotv = max(dot(n, v), 0.000001);
            vec3 worldN = inverseTransformDirection( n, viewMatrix );
            vec3 worldV = cameraPosition - wPosition ;
            vec3 r = normalize( reflect(-worldV,worldN));

            cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
            cdiff = pow(cdiff, vec3(2.2));

            cspec = texture2D( specularMap, vUv*textureRepeat).rgb;
            cspec = pow(cspec, vec3(2.2));

            vec3 totalColor;
            for (int i = 0; i < 8; i++) {
                vec4 lPosition = viewMatrix * vec4(pointLightPosition[i], 1.0);
                vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 h = normalize(v + l);
                float nDotl = max(dot(n, l), 0.000001);
                float lDoth = max(dot(l, h), 0.000001);
                float nDoth = max(dot(n, h), 0.000001);

                // specular BRDF
                float a = nDoth * roughness;
                float D = D_GGX(nDoth, a);
                float V = V_SmithGGXCorrelated(nDotv, nDotl, roughness);
                vec3  F = F_Schlick(lDoth, 0.16*cspec*cspec);
                vec3 Fr = (D * V) * F;

                // diffuse BRDF
                vec3 Fd = cdiff * Fd_Lambert();

                vec3 color = mix(Fr, Fd, 0.5);
                color *= clight * nDotl;
                totalColor += color;
            }

            gl_FragColor = vec4(pow(totalColor, vec3(1.0/2.2)), 1.0);
        }
    </script>

    <script type="text/x-glsl" id="fragment_wood">
        #define MEDIUMP_FLT_MAX    65504.0
        #define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
        varying vec3 vNormal;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        varying vec3 vPosition;
        varying vec3 wPosition;
        varying vec2 vUv;
        uniform vec3 pointLightPosition[8];
        uniform vec3 clight;
        uniform sampler2D diffuseMap;
        uniform sampler2D roughnessMap;
        uniform sampler2D normalMap;
        uniform samplerCube envMap;
        uniform vec2 normalScale;
        uniform vec2 textureRepeat;
        const float PI = 3.14159;

        vec3 cdiff;
        float roughness;

        float D_GGX(float NoH, float a) {
            float a2 = a * a;
            float f = (NoH * a2 - NoH) * NoH + 1.0;
            return a2 / (PI * f * f);
        }

        vec3 F_Schlick(float u, vec3 f0) {
            return f0 + (vec3(1.0) - f0) * pow(1.0 - u, 5.0);
        }

        float V_SmithGGXCorrelated(float NoV, float NoL, float a) {
            float a2 = a * a;
            float GGXL = NoV * sqrt((-NoL * a2 + NoL) * NoL + a2);
            float GGXV = NoL * sqrt((-NoV * a2 + NoV) * NoV + a2);
            return 0.5 / (GGXV + GGXL);
        }

        float Fd_Lambert() {
            return 1.0 / PI;
        }

        vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
            return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
        }

        void main() {
            vec3 v = normalize(-vPosition);
            vec3 normal = normalize( vNormal );
            vec3 tangent = normalize( vTangent );
            vec3 bitangent = normalize( vBitangent );
            mat3 vTBN = mat3( tangent, bitangent, normal );
            vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
            mapN.xy = normalScale * mapN.xy;
            vec3 n = normalize( vTBN * mapN );
            roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
            float nDotv = max(dot(n, v), 0.000001);
            vec3 worldN = inverseTransformDirection( n, viewMatrix );
            vec3 worldV = cameraPosition - wPosition ;
            vec3 r = normalize( reflect(-worldV,worldN));

            cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
            cdiff = pow(cdiff, vec3(2.2));

            vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz)).rgb;
			envLight = pow( envLight, vec3(2.2));

            vec3 totalColor;
            for (int i = 0; i < 8; i++) {
                vec4 lPosition = viewMatrix * vec4(pointLightPosition[i], 1.0);
                vec3 l = normalize(lPosition.xyz - vPosition.xyz);
                vec3 h = normalize(v + l);
                float nDotl = max(dot(n, l), 0.000001);
                float lDoth = max(dot(l, h), 0.000001);
                float nDoth = max(dot(n, h), 0.000001);

                // specular BRDF
                float a = nDoth * roughness;
                float D = D_GGX(nDoth, a);
                float V = V_SmithGGXCorrelated(nDotv, nDotl, roughness);
                vec3  F = F_Schlick(lDoth, vec3(0.16 * 0.5 * 0.5));
                vec3 Fr = (D * V) * F;

                // diffuse BRDF
                vec3 Fd = cdiff * Fd_Lambert();

                vec3 color = mix(Fr, Fd, 0.5);
                color *= clight * nDotl;
                color = mix(color, envLight * F, 0.01);
                totalColor += color;
            }

            gl_FragColor = vec4(pow(totalColor, vec3(1.0/2.2)), 1.0);
        }
    </script>

    <!--Fragment shader-->
    <script type="text/x-glsl" id="fragment_cloth">
    #define MEDIUMP_FLT_MAX    65504.0
    #define saturateMediump(x) min(x, MEDIUMP_FLT_MAX)
    varying vec3 vNormal;
    varying vec3 vTangent;
    varying vec3 vBitangent;
    varying vec3 vPosition;
    varying vec3 wPosition;
    varying vec2 vUv;
    uniform vec3 pointLightPosition[8];
    uniform vec3 clight;
    uniform sampler2D specularMap;
    uniform sampler2D diffuseMap;
    uniform sampler2D roughnessMap;
    uniform sampler2D normalMap;
    uniform vec2 normalScale;
    uniform vec2 textureRepeat;
    const float PI = 3.14159;

    vec3 cdiff;
    vec3 cspec;
    float roughness;

    float pow5(float x) {
        float x2 = x * x;
        return x2 * x2 * x;
    }

    float F_Schlick(float f0, float f90, float VoH) {
        return f0 + (f90 - f0) * pow5(1.0 - VoH);
    }

    float Fd_Burley(float roughness, float NoV, float NoL, float LoH) {
        // Burley 2012, "Physically-Based Shading at Disney"
        float f90 = 0.5 + 2.0 * roughness * LoH * LoH;
        float lightScatter = F_Schlick(1.0, f90, NoL);
        float viewScatter  = F_Schlick(1.0, f90, NoV);
        return lightScatter * viewScatter * (1.0 / PI);
    }

    float V_Neubelt(float NoV, float NoL) {
        // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
        return saturateMediump(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
    }

    float D_Charlie(float roughness, float NoH) {
        // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
        float invAlpha  = 1.0 / roughness;
        float cos2h = NoH * NoH;
        float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
        return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
    }

    void main() {
        vec3 v = normalize(-vPosition);
        vec3 normal = normalize( vNormal );
        vec3 tangent = normalize( vTangent );
        vec3 bitangent = normalize( vBitangent );
        mat3 vTBN = mat3( tangent, bitangent, normal );
        vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
        mapN.xy = normalScale * mapN.xy;
        vec3 n = normalize( vTBN * mapN );
        roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
        float nDotv = max(dot(n, v), 0.000001);

        cdiff = texture2D( diffuseMap, vUv*textureRepeat ).rgb;
        cdiff = pow(cdiff, vec3(2.2));

        cspec = texture2D( specularMap, vUv*textureRepeat).rgb;
        cspec = pow(cspec, vec3(2.2));

        vec3 totalColor;
        for (int i = 0; i < 6; i++) {
            vec4 lPosition = viewMatrix * vec4(pointLightPosition[i], 1.0);
            vec3 l = normalize(lPosition.xyz - vPosition.xyz);
            vec3 h = normalize(v + l);
            float nDotl = max(dot(n, l), 0.000001);
            float lDoth = max(dot(l, h), 0.000001);
            float nDoth = max(dot(n, h), 0.000001);

            // specular BRDF
            float D = D_Charlie(roughness, nDoth);
            float V = V_Neubelt(nDotv, nDotl);
            vec3  F = sqrt(cspec);
            vec3 Fr = (D * V) * F;

            // diffuse BRDF
            float diffuse = Fd_Burley(roughness, nDotv, nDotl, lDoth);
            vec3 Fd = diffuse * cdiff;

            vec3 color = Fd + Fr;
            color *= clight * nDotl;
            totalColor += color;
        }

        gl_FragColor = vec4(pow(totalColor, vec3(1.0/2.2)), 1.0);
    }
    </script>
</head>

<body>
<!-- Three js code-->
<script type="module" src="./code.js"></script>

<!-- Header code-->
<div id="header"></div>

<canvas></canvas> <!-- Canvas for Threejs scene-->

<!-- Menu -->
<div class="shadow p-3 mb-5 bg-white rounded controls">
    <h1>Info</h1>
    <hr/>
    Scegli una colorazione
    <select class="form-select" aria-label="Default select example">
        <option selected value="1">One</option>
        <option value="2">Two</option>
        <option value="3">Three</option>
    </select>


    <hr/>

    Scegli una patata
    <select class="form-select" aria-label="Default select example">
        <option selected value="1">One</option>
        <option value="2">Two</option>
        <option value="3">Three</option>
    </select>

    <hr/>

    <p><strong>Prezzo</strong>: TANTI € </p>

    <button type="button" class="btn btn-secondary">Chiudi</button>

</div>

<!-- Menu button -->
<div id="menu">
    <button type="button" class="btn btn-light">Menu</button>
</div>

<!-- Functions to load components and interact with menu-->
<script>

    var controls = false;

    function loadMainPage() {
        $("#header").load("header.html")
        $(".controls").hide();
    }

    $("#dropdown").click(function () {
        $(".content").fadeIn("slow");
    })

    $(document).ready(function () {
        $("canvas").hide().fadeIn(1000);
    });


    $("#menu > button").click(function () {
        if (!controls) {
            $(".controls").fadeIn("fast");
            controls = true;
            $("#menu").hide();
        }
    })

    $(".controls > button").click(function () {
        if (controls) {
            $(".controls").fadeOut("fast");
            controls = false;
            $("#menu").fadeIn("fast");
        }
    })

    loadMainPage();
</script>

</body>
</html>