<html>

<head>
    <title>Test</title>
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <script src="libs/three.js"></script>
    <script src="libs/stats.min.js"></script>
    <script src="libs/OrbitControls.js"></script>
    <script src="libs/OBJLoader.js"></script>
    <script src='libs/dat.gui.min.js'></script>
</head>

<body>

<script type="text/x-glsl" id="vertex">
		varying vec3 vNormal;
		varying vec3 vPosition;
		varying vec2 uVv;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
			vPosition = vPos.xyz;
			vNormal = normalMatrix * normal;
			uVv = uv;
			gl_Position = projectionMatrix * vPos;
		}

</script>

<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vPosition;
			varying vec2 uVv;
			uniform vec3 pointLightPosition; // in world space
			uniform vec3 clight;
			uniform sampler2D specularMap;
			uniform sampler2D diffuseMap;
			uniform sampler2D roughnessMap;
			uniform vec2 textureRepeat;
			const float PI = 3.14159;

			vec3 cdiff;
			vec3 cspec;
			float roughness;

			vec3 FSchlick(float vDoth, vec3 f0) {
				return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
			}

			float DGGX(float NoH, float alpha) {
				float alpha2 = alpha * alpha;
				float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
    			return alpha2 / (PI * k * k );
			}

			float G1(float nDotv, float alpha) {
				float alpha2 = alpha*alpha;
				return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
			}

			float GSmith(float nDotv, float nDotl, float alpha) {
				return G1(nDotl,alpha)*G1(nDotv,alpha);
			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 n = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				// small quantity to prevent divisions by 0
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
				float nDotv = max(dot( n, v ),0.000001);

				cdiff = texture2D( diffuseMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cdiff = pow( cdiff, vec3(2.2));
				cspec = texture2D( specularMap, uVv*textureRepeat ).rgb;
				// texture in sRGB, linearize
				cspec = pow( cspec, vec3(2.2));
				roughness = texture2D( roughnessMap, uVv*textureRepeat).r; // no need to linearize roughness map
				vec3 fresnel = FSchlick(vDoth, cspec);
				float alpha = roughness * roughness;
				vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/
					(4.0*nDotl*nDotv);
				vec3 outRadiance = PI* clight * nDotl * BRDF;
				// gamma encode the final value
				gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
			}

</script>

<script type="module">
    import {RGBELoader} from './libs/RGBELoader.js';

    let gui, textureParams, vs, fs;

    vs = document.getElementById("vertex").textContent;
    fs = document.getElementById("fragment").textContent;

    const scene = new THREE.Scene();

    let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 100);
    camera.position.set(0, 0, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)

    var textureParameters = {
        material: "Metal",
        repeatS: 1.0,
        repeatT: 1.0
    }

    let diffuseMap = loadTexture("materials/" + textureParameters.material + "/" + textureParameters.material + "_Color.jpg");
    let specularMap = loadTexture("materials/" + textureParameters.material + "/" + textureParameters.material + "_Specular.jpg");
    let roughnessMap = loadTexture("materials/" + textureParameters.material + "/" + textureParameters.material + "_Roughness.jpg");

    new RGBELoader()
        .load('studio_country_hall_1k.hdr', texture => {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
            scene.environment = texture;
            render()
        });

    // lights

    let ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    let directionalLight_1 = new THREE.DirectionalLight(0xffffff, 0.1);
    directionalLight_1.position.set(32, 0, 40);
    scene.add(new THREE.DirectionalLightHelper(directionalLight_1, 5))
    scene.add(directionalLight_1);
    let directionalLight_2 = new THREE.DirectionalLight(0xffffff, 0.1);
    directionalLight_2.position.set(8, 0, 40);
    scene.add(new THREE.DirectionalLightHelper(directionalLight_2, 5))
    scene.add(directionalLight_2);
    let directionalLight_3 = new THREE.DirectionalLight(0xffffff, 0.1);
    directionalLight_3.position.set(40, 0, 16);
    scene.add(new THREE.DirectionalLightHelper(directionalLight_3, 5))
    scene.add(directionalLight_3);
    let directionalLight_4 = new THREE.DirectionalLight(0xffffff, 0.1);
    directionalLight_4.position.set(0, 0, -40);
    scene.add(new THREE.DirectionalLightHelper(directionalLight_4, 5))
    scene.add(directionalLight_4);

    let ourMaterial = new THREE.ShaderMaterial({ uniforms: uniforms, vertexShader: vs, fragmentShader: fs });
    const objLoader = new THREE.OBJLoader()
    objLoader.load(
        'obj/wineglasses.obj',
        function (object) {
            let glass = object.children[1]
            glass.traverse((child) => {
                if (child instanceof THREE.Mesh) {
                    child.material = ourMaterial
                }
            });
            glass.geometry.center();
            scene.add(glass);
        },
        function (xhr) {
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function (error) {
            console.log('An error happened');
        }
    );

    var uniforms = {
        specularMap: { type: "t", value: specularMap},
        diffuseMap:	{ type: "t", value: diffuseMap},
        roughnessMap:	{ type: "t", value: roughnessMap},
        pointLightPosition:	{ type: "v3", value: new THREE.Vector3() },
        clight:	{ type: "v3", value: new THREE.Vector3() },
        textureRepeat: { type: "v2", value: new THREE.Vector2(1,1) }
    };

    const controls = new THREE.OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true

    window.addEventListener('resize', onWindowResize, false)

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()
        renderer.setSize(window.innerWidth, window.innerHeight)
        render()
    }

    const stats = Stats()
    document.body.appendChild(stats.dom)

    function animate() {
        requestAnimationFrame(animate)
        buildGui()
        controls.update()
        render()
        stats.update()
    }

    function render() {
        renderer.render(scene, camera)
    }

    function loadTexture(file) {
        let texture = new THREE.TextureLoader().load(file, texture => {
            // Fare qualcosa
            render();
        })
        return texture;
    }

    function clearGui() {
        if (gui) gui.destroy();
        gui = new dat.GUI();
        gui.open();
    }

    function buildGui() {

        clearGui();
        let textureSettings = gui.addFolder('Texture parameters');
        textureSettings.add(textureParameters, 'material', ['Wood', 'Metal', 'Plastic']).onChange(
            function (material) {
                diffuseMap = loadTexture("materials/" + material + "/" + material + "_Color.jpg");
                specularMap = loadTexture("materials/" + material + "/" + material + "_Specular.jpg");
                roughnessMap = loadTexture("materials/" + material + "/" + material + "_Roughness.jpg");
                ourMaterial.needsUpdate = true;
                render()
            });
    }

    animate()
</script>
</body>

</html>